{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python library for building bots to interact with Discord Slash Commands Before we start. \u00b6 This library has not left the alpha stage and will have bugs and issues. I ask you to please remember this when opening issues or creating PRs. This library assumes you will be building an independent server to receive and send requests from/to Discord directly. This may cause higher bandwidth usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this, the bot will only bind to localhost and accept local connections. If you want to do local testing before creating a server, you can use free tools such as Ngrok . This library is only tested on python versions 3.9 3.8 3.7 3.6 API Parity List \u00b6 Info Just because it's been implemented does not mean it's in the best way. Help out by contributing to this library! API Endpoint Implementation Get Global Application Commands \u2705 Implemented Create Global Application Command \u2705 Implemented Edit Global Application Command \u2705 Implemented Delete Global Application Command \u2705 Implemented Create Guild Application Command \u2705 Implemented Edit Guild Application Command \u2705 Implemented Delete Guild Application Command \u2705 Implemented Create Interaction Response \u2705 Implemented Edit Original Interaction Response \u2705 Implemented Delete Original Interaction Response \u2705 Implemented Create Followup Message \u2705 Implemented Edit Followup Message \u2705 Implemented Delete Followup Message \u2705 Implemented Data Models and Types \u2705 Implemented ApplicationCommand \u2705 Implemented ApplicationCommandOption \u2705 Implemented ApplicationCommandOptionType \u2705 Implemented ApplicationCommandOptionChoice \u2705 Implemented Interaction \u2705 Implemented Interaction Response \u2705 Implemented Special Thanks \u00b6 Squidtoon99","title":"Home"},{"location":"#before-we-start","text":"This library has not left the alpha stage and will have bugs and issues. I ask you to please remember this when opening issues or creating PRs. This library assumes you will be building an independent server to receive and send requests from/to Discord directly. This may cause higher bandwidth usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this, the bot will only bind to localhost and accept local connections. If you want to do local testing before creating a server, you can use free tools such as Ngrok . This library is only tested on python versions 3.9 3.8 3.7 3.6","title":"Before we start."},{"location":"#api-parity-list","text":"Info Just because it's been implemented does not mean it's in the best way. Help out by contributing to this library! API Endpoint Implementation Get Global Application Commands \u2705 Implemented Create Global Application Command \u2705 Implemented Edit Global Application Command \u2705 Implemented Delete Global Application Command \u2705 Implemented Create Guild Application Command \u2705 Implemented Edit Guild Application Command \u2705 Implemented Delete Guild Application Command \u2705 Implemented Create Interaction Response \u2705 Implemented Edit Original Interaction Response \u2705 Implemented Delete Original Interaction Response \u2705 Implemented Create Followup Message \u2705 Implemented Edit Followup Message \u2705 Implemented Delete Followup Message \u2705 Implemented Data Models and Types \u2705 Implemented ApplicationCommand \u2705 Implemented ApplicationCommandOption \u2705 Implemented ApplicationCommandOptionType \u2705 Implemented ApplicationCommandOptionChoice \u2705 Implemented Interaction \u2705 Implemented Interaction Response \u2705 Implemented","title":"API Parity List"},{"location":"#special-thanks","text":"Squidtoon99","title":"Special Thanks"},{"location":"FollowUpMessages/","text":"Follow Up Messages \u00b6 Follow-up messages are a feature that allows for responses to sent after an initial response has been already been sent. Info This module offers methods both in async and sync. Methods regarding editing and sending will require a DiscordResponse . \u00b6 __init__ ( self , bot , interaction ) special \u00b6 A module to handle Follow Up Messages. Parameters: Name Type Description Default bot Dispike An already initalized dispike object. required interaction IncomingDiscordInteraction An incoming Discord Interaction required Source code in dispike/followup/main.py def __init__ ( self , bot : \"Dispike\" , interaction : \"IncomingDiscordInteraction\" , ): \"\"\"A module to handle Follow Up Messages. Args: bot (Dispike): An already initalized dispike object. interaction (IncomingDiscordInteraction): An incoming Discord Interaction \"\"\" self . _application_id = bot . _application_id self . _interaction_token = interaction . token self . base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { self . _interaction_token } \" self . _async_client = httpx . AsyncClient ( base_url = self . base_url ) self . _sync_client = httpx . Client ( base_url = self . base_url ) self . _message_id = None async_create_follow_up_message ( self , message ) async \u00b6 Create an initial follow up message. (Async) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py async def async_create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Async) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if isinstance ( message , DiscordResponse ) == False : raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id != None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = await self . _async_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise async_delete_follow_up_message ( self ) async \u00b6 Deletes an already sent initial follow-up message. (Async) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py async def async_delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (Async) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = await self . _async_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise async_edit_follow_up_message ( self , updated_message ) async \u00b6 Edit an already sent initial follow-up message. (Async) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py async def async_edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Async) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = await self . _async_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise create_follow_up_message ( self , message ) \u00b6 Create an initial follow up message. (Sync) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py def create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Sync) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if isinstance ( message , DiscordResponse ) == False : raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id != None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = self . _sync_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise delete_follow_up_message ( self ) \u00b6 Deletes an already sent initial follow-up message. (sync) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py def delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (sync) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = self . _sync_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise edit_follow_up_message ( self , updated_message ) \u00b6 Edit an already sent initial follow-up message. (Sync) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py def edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Sync) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = self . _sync_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"Follow Up Messages"},{"location":"FollowUpMessages/#follow-up-messages","text":"Follow-up messages are a feature that allows for responses to sent after an initial response has been already been sent. Info This module offers methods both in async and sync. Methods regarding editing and sending will require a DiscordResponse .","title":"Follow Up Messages"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages","text":"","title":"dispike.followup.main.FollowUpMessages"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.__init__","text":"A module to handle Follow Up Messages. Parameters: Name Type Description Default bot Dispike An already initalized dispike object. required interaction IncomingDiscordInteraction An incoming Discord Interaction required Source code in dispike/followup/main.py def __init__ ( self , bot : \"Dispike\" , interaction : \"IncomingDiscordInteraction\" , ): \"\"\"A module to handle Follow Up Messages. Args: bot (Dispike): An already initalized dispike object. interaction (IncomingDiscordInteraction): An incoming Discord Interaction \"\"\" self . _application_id = bot . _application_id self . _interaction_token = interaction . token self . base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { self . _interaction_token } \" self . _async_client = httpx . AsyncClient ( base_url = self . base_url ) self . _sync_client = httpx . Client ( base_url = self . base_url ) self . _message_id = None","title":"__init__()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.async_create_follow_up_message","text":"Create an initial follow up message. (Async) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py async def async_create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Async) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if isinstance ( message , DiscordResponse ) == False : raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id != None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = await self . _async_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"async_create_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.async_delete_follow_up_message","text":"Deletes an already sent initial follow-up message. (Async) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py async def async_delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (Async) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = await self . _async_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"async_delete_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.async_edit_follow_up_message","text":"Edit an already sent initial follow-up message. (Async) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py async def async_edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Async) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = await self . _async_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"async_edit_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.create_follow_up_message","text":"Create an initial follow up message. (Sync) Parameters: Name Type Description Default message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py def create_follow_up_message ( self , message : DiscordResponse ): \"\"\"Create an initial follow up message. (Sync) Args: message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if isinstance ( message , DiscordResponse ) == False : raise TypeError ( \"Message must be a DiscordResponse\" ) message . _switch_to_followup_message () if self . _message_id != None : raise TypeError ( \"Creating a followup message can only be done once.\" ) try : _request = self . _sync_client . post ( url = self . base_url , json = message . response ) logger . info ( \"sent request for creation of follow up to discord..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : logger . error ( f \"discord returned a bad status code: { _request . status_code } -> { _request . text } url: { _request . url } \" ) raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"create_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.delete_follow_up_message","text":"Deletes an already sent initial follow-up message. (sync) Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py def delete_follow_up_message ( self ): \"\"\"Deletes an already sent initial follow-up message. (sync) Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first.\" ) try : _request = self . _sync_client . delete ( f \"/messages/ { self . _message_id } \" ) logger . info ( f \"sent request for deletion of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 , 204 ]: self . _message_id = None return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"delete_follow_up_message()"},{"location":"FollowUpMessages/#dispike.followup.main.FollowUpMessages.edit_follow_up_message","text":"Edit an already sent initial follow-up message. (Sync) Parameters: Name Type Description Default updated_message DiscordResponse An already created discord response required Returns: Type Description True If request is successfully made. An exception will rise otherwise Exceptions: Type Description DiscordAPIError Discord returning a non-OK status status_code TypeError Invalid type passed. Source code in dispike/followup/main.py def edit_follow_up_message ( self , updated_message : DiscordResponse ): \"\"\"Edit an already sent initial follow-up message. (Sync) Args: updated_message (DiscordResponse): An already created discord response Returns: True: If request is successfully made. An exception will rise otherwise Raises: DiscordAPIError: Discord returning a non-OK status status_code TypeError: Invalid type passed. \"\"\" if self . _message_id == None : raise TypeError ( \"a followup message must be sent first!\" ) try : _request = self . _sync_client . patch ( f \"/messages/ { self . _message_id } \" , json = updated_message . response ) logger . info ( f \"sent request for edit of follow up to discord [ { self . _message_id } ]..\" ) if _request . status_code in [ 200 , 201 ]: _parse_request = _request . json () self . _message_id = _parse_request [ \"id\" ] return True else : raise DiscordAPIError ( _request . status_code , _request . text ) except DiscordAPIError : raise except Exception : logger . exception ( \"error creating message.\" ) raise","title":"edit_follow_up_message()"},{"location":"APIRef/Dispike/","text":"Dispike \u00b6 Initalizing Dispike will require - A valid client public key - A valid bot token - A valid client id (Dispike references this as an application id.) All of these values can be found in the Discord Developer Portal. Run command \u00b6 The run method is available as a convenience to quickly start a HTTP server that can accept connections. While this HTTP server itself is production-ready, you should run this behind a reverse-proxy such as Nginx , Apache or Caddy. The run method will only bind to a local connection and over a non-standard HTTP port. - Recommended Dispike Reference \u00b6 \u00b6 Dispike - python library for interacting with discord slash commands via an independently hosted server. Powered by FastAPI interaction: EventHandler property readonly \u00b6 Returns an already initialized EventHandler object. You will use this method to handle incoming commands. Returns: Type Description EventHandler EventHandler: shared EventHandler referenced_application: FastAPI property readonly \u00b6 Returns the internal FastAPI object that was initialized. You are welcome to edit this with the appropriate settings found in the FastAPI docs. Returns: Type Description FastAPI FastAPI: a pre-configured FastAPI object with required middlewares. register: < function RegisterCommands . register at 0x7f4edb2784d0 > property readonly \u00b6 Returns a shortcut the RegisterCommands.register function Returns: Type Description <function RegisterCommands.register at 0x7f4edb2784d0> RegisterCommands.register: internal RegisterCommands Object shared_client: httpx . Client property readonly \u00b6 Returns a pre-initialized httpx.Client that is used for requests internally. Returns: Type Description httpx.Client httpx.Client: used for network requests to discord. __init__ ( self , client_public_key , bot_token , application_id , ** kwargs ) special \u00b6 Initialize Dispike Object Parameters: Name Type Description Default client_public_key str Discord provided client public key. required bot_token str Discord provided bot token. You must create a bot user to view this! required application_id str Discord provided Client ID required custom_context_argument_name str Change the name of the context arugment when passing to a function. Set to \"ctx\". required Source code in dispike/main.py def __init__ ( self , client_public_key : str , bot_token : str , application_id : str , ** kwargs ): \"\"\"Initialize Dispike Object Args: client_public_key (str): Discord provided client public key. bot_token (str): Discord provided bot token. You must create a bot user to view this! application_id (str): Discord provided Client ID custom_context_argument_name (str, optional): Change the name of the context arugment when passing to a function. Set to \"ctx\". \"\"\" self . _bot_token = bot_token self . _application_id = application_id self . _registrator = RegisterCommands ( application_id = self . _application_id , bot_token = self . _bot_token ) self . _internal_application = FastAPI () self . _internal_application . add_middleware ( DiscordVerificationMiddleware , client_public_key = client_public_key ) self . _internal_application . include_router ( router = router ) if not kwargs . get ( \"custom_context_argument_name\" ): router . _user_defined_setting_ctx_value = \"ctx\" else : router . _user_defined_setting_ctx_value = kwargs . get ( \"custom_context_argument_name\" ) self . _cache_router = router async_get_all_command_permissions_in_guild ( self , guild_id ) async \u00b6 Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.register.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py async def async_get_all_command_permissions_in_guild ( self , guild_id ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" ) _request_command_permission . raise_for_status () return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) async_get_command_permission_in_guild ( self , command_id , guild_id ) async \u00b6 Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py async def async_get_command_permission_in_guild ( self , command_id , guild_id ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" ) if _request_command_permission . status_code == 404 : return None else : _request_command_permission . raise_for_status () return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) async_set_command_permission ( self , command_id , guild_id , new_permissions ) async \u00b6 Set a permissions for a command in a specific guild. This function is async! Parameters: Name Type Description Default command_id int Command ID required guild_id int Guild ID required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool [bool]: True, if the command has been successfully edited. Source code in dispike/main.py async def async_set_command_permission ( self , command_id , guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is async! Args: command_id (int): Command ID guild_id (int): Guild ID new_permissions (NewApplicationPermission): Permissions for this command. Returns: [bool]: True, if the command has been successfully edited. \"\"\" async with httpx . AsyncClient () as client : try : _set_command_permissions = await client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , data = new_permissions . dict (), headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) return False delete_command ( self , command_id , guild_only = False , guild_id_passed = None ) \u00b6 Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id int Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def delete_command ( self , command_id : int , guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (int): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise edit_command ( self , new_command , command_id = None , bulk = False , guild_only = False , guild_id_passed = False ) \u00b6 Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id int Command ID None new_command Union[List[dispike.register.models.options.DiscordCommand], dispike.register.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : int = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk == True : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk == True : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False get_all_command_permissions_in_guild ( self , guild_id ) \u00b6 Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.register.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py def get_all_command_permissions_in_guild ( self , guild_id : typing . Union [ str , int ] ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" , headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _request_command_permission . raise_for_status () return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } \" ) get_command_permission_in_guild ( self , command_id , guild_id ) \u00b6 Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py def get_command_permission_in_guild ( self , command_id : typing . Union [ str , int ], guild_id : typing . Union [ str , int ] ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) if _request_command_permission . status_code == 404 : return None else : _request_command_permission . raise_for_status () return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } { _request_command_permission . text } \" ) get_commands ( self , guild_only = False , guild_id_passed = None ) \u00b6 Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.models.incoming.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise reset_registration ( self , new_bot_token = None , new_application_id = None ) \u00b6 This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Parameters: Name Type Description Default new_bot_token None Description None new_application_id None Description None Returns: Type Description TYPE bool Source code in dispike/main.py def reset_registration ( self , new_bot_token = None , new_application_id = None ): \"\"\"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Args: new_bot_token (None, optional): Description new_application_id (None, optional): Description Returns: TYPE: bool \"\"\" try : if new_bot_token == None : _bot_token = self . _bot_token else : _bot_token = new_bot_token if new_application_id == None : _application_id = self . _application_id else : _application_id = new_application_id self . _registrator = RegisterCommands ( application_id = _application_id , bot_token = _bot_token ) self . _bot_token = _bot_token self . _application_id = _application_id return True except Exception : return False run ( self , port = 5000 ) \u00b6 Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Port to run the bot over. Defaults to 5000. 5000 Source code in dispike/main.py def run ( self , port : int = 5000 ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Port to run the bot over. Defaults to 5000. \"\"\" uvicorn = self . _return_uvicorn_run_function () uvicorn . run ( app = self . referenced_application , port = port ) send_deferred_message ( self , original_context , new_message ) async \u00b6 Send a deferred message. Parameters: Name Type Description Default original_context IncomingDiscordInteraction The orginal context of the message. required new_message DiscordResponse Message to send. required Source code in dispike/main.py async def send_deferred_message ( self , original_context : \"IncomingDiscordInteraction\" , new_message : \"DiscordResponse\" , ): \"\"\"Send a deferred message. Args: original_context (IncomingDiscordInteraction): The orginal context of the message. new_message (DiscordResponse): Message to send. \"\"\" async with httpx . AsyncClient ( base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { original_context . token } /messages/\" , headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) as client : try : # TODO: Probably change later to inside the DeferredResponse? new_message . _switch_to_followup_message () response = await client . patch ( \"/@original\" , data = new_message . response ) response . raise_for_status () except httpx . HTTPError : logger . exception ( f \"Unable to send deferred message with error: { response . text } \" ) set_command_permission ( self , command_id , guild_id , new_permissions ) \u00b6 Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id int Command ID required guild_id int Guild ID required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool [bool]: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id , guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (int): Command ID guild_id (int): Guild ID new_permissions (NewApplicationPermission): Permissions for this command. Returns: [bool]: True, if the command has been successfully edited. \"\"\" with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False","title":"Dispike"},{"location":"APIRef/Dispike/#dispike","text":"Initalizing Dispike will require - A valid client public key - A valid bot token - A valid client id (Dispike references this as an application id.) All of these values can be found in the Discord Developer Portal.","title":"Dispike"},{"location":"APIRef/Dispike/#run-command","text":"The run method is available as a convenience to quickly start a HTTP server that can accept connections. While this HTTP server itself is production-ready, you should run this behind a reverse-proxy such as Nginx , Apache or Caddy. The run method will only bind to a local connection and over a non-standard HTTP port. - Recommended","title":"Run command"},{"location":"APIRef/Dispike/#dispike-reference","text":"","title":"Dispike Reference"},{"location":"APIRef/Dispike/#dispike.main.Dispike","text":"Dispike - python library for interacting with discord slash commands via an independently hosted server. Powered by FastAPI","title":"dispike.main.Dispike"},{"location":"APIRef/Dispike/#dispike.main.Dispike.interaction","text":"Returns an already initialized EventHandler object. You will use this method to handle incoming commands. Returns: Type Description EventHandler EventHandler: shared EventHandler","title":"interaction"},{"location":"APIRef/Dispike/#dispike.main.Dispike.referenced_application","text":"Returns the internal FastAPI object that was initialized. You are welcome to edit this with the appropriate settings found in the FastAPI docs. Returns: Type Description FastAPI FastAPI: a pre-configured FastAPI object with required middlewares.","title":"referenced_application"},{"location":"APIRef/Dispike/#dispike.main.Dispike.register","text":"Returns a shortcut the RegisterCommands.register function Returns: Type Description <function RegisterCommands.register at 0x7f4edb2784d0> RegisterCommands.register: internal RegisterCommands Object","title":"register"},{"location":"APIRef/Dispike/#dispike.main.Dispike.shared_client","text":"Returns a pre-initialized httpx.Client that is used for requests internally. Returns: Type Description httpx.Client httpx.Client: used for network requests to discord.","title":"shared_client"},{"location":"APIRef/Dispike/#dispike.main.Dispike.__init__","text":"Initialize Dispike Object Parameters: Name Type Description Default client_public_key str Discord provided client public key. required bot_token str Discord provided bot token. You must create a bot user to view this! required application_id str Discord provided Client ID required custom_context_argument_name str Change the name of the context arugment when passing to a function. Set to \"ctx\". required Source code in dispike/main.py def __init__ ( self , client_public_key : str , bot_token : str , application_id : str , ** kwargs ): \"\"\"Initialize Dispike Object Args: client_public_key (str): Discord provided client public key. bot_token (str): Discord provided bot token. You must create a bot user to view this! application_id (str): Discord provided Client ID custom_context_argument_name (str, optional): Change the name of the context arugment when passing to a function. Set to \"ctx\". \"\"\" self . _bot_token = bot_token self . _application_id = application_id self . _registrator = RegisterCommands ( application_id = self . _application_id , bot_token = self . _bot_token ) self . _internal_application = FastAPI () self . _internal_application . add_middleware ( DiscordVerificationMiddleware , client_public_key = client_public_key ) self . _internal_application . include_router ( router = router ) if not kwargs . get ( \"custom_context_argument_name\" ): router . _user_defined_setting_ctx_value = \"ctx\" else : router . _user_defined_setting_ctx_value = kwargs . get ( \"custom_context_argument_name\" ) self . _cache_router = router","title":"__init__()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.async_get_all_command_permissions_in_guild","text":"Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.register.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py async def async_get_all_command_permissions_in_guild ( self , guild_id ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" ) _request_command_permission . raise_for_status () return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } \" )","title":"async_get_all_command_permissions_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.async_get_command_permission_in_guild","text":"Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py async def async_get_command_permission_in_guild ( self , command_id , guild_id ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" async with httpx . AsyncClient () as client : try : _request_command_permission = await client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" ) if _request_command_permission . status_code == 404 : return None else : _request_command_permission . raise_for_status () return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } \" )","title":"async_get_command_permission_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.async_set_command_permission","text":"Set a permissions for a command in a specific guild. This function is async! Parameters: Name Type Description Default command_id int Command ID required guild_id int Guild ID required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool [bool]: True, if the command has been successfully edited. Source code in dispike/main.py async def async_set_command_permission ( self , command_id , guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is async! Args: command_id (int): Command ID guild_id (int): Guild ID new_permissions (NewApplicationPermission): Permissions for this command. Returns: [bool]: True, if the command has been successfully edited. \"\"\" async with httpx . AsyncClient () as client : try : _set_command_permissions = await client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , data = new_permissions . dict (), headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) return False","title":"async_set_command_permission()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.delete_command","text":"Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id int Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def delete_command ( self , command_id : int , guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (int): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"delete_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.edit_command","text":"Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id int Command ID None new_command Union[List[dispike.register.models.options.DiscordCommand], dispike.register.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : int = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk == True : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk == True : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False","title":"edit_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_all_command_permissions_in_guild","text":"Return permissions for all commands in a guild. Parameters: Name Type Description Default guild_id Union[str, int] ID of guild. required Returns: Type Description List[dispike.register.models.permissions.GuildApplicationCommandPermissions] typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) Source code in dispike/main.py def get_all_command_permissions_in_guild ( self , guild_id : typing . Union [ str , int ] ) -> typing . List [ GuildApplicationCommandPermissions ]: \"\"\"Return permissions for all commands in a guild. Args: guild_id (typing.Union[str, int]): ID of guild. Returns: typing.List[GuildApplicationCommandPermissions]: Permissions for all commands (if any permissions exist.) \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/permissions\" , headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _request_command_permission . raise_for_status () return [ GuildApplicationCommandPermissions ( ** x ) for x in _request_command_permission . json () ] except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } \" )","title":"get_all_command_permissions_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_command_permission_in_guild","text":"Return permissions for a single command in a guild. If no permissions are available, it will return None. Parameters: Name Type Description Default command_id Union[str, int] Command ID required guild_id Union[str, int] Guild ID required Returns: Type Description GuildApplicationCommandPermissions GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. Source code in dispike/main.py def get_command_permission_in_guild ( self , command_id : typing . Union [ str , int ], guild_id : typing . Union [ str , int ] ) -> GuildApplicationCommandPermissions : \"\"\"Return permissions for a single command in a guild. If no permissions are available, it will return None. Args: command_id (typing.Union[str, int]): Command ID guild_id (typing.Union[str, int]): Guild ID Returns: GuildApplicationCommandPermissions: Return if permissions exist. None: Return if no permissions exist. \"\"\" with httpx . Client () as client : try : _request_command_permission = client . get ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) if _request_command_permission . status_code == 404 : return None else : _request_command_permission . raise_for_status () return GuildApplicationCommandPermissions ( ** _request_command_permission . json () ) except httpx . HTTPError : logger . exception ( f \"Unable to get command permission! { _request_command_permission . status_code } { _request_command_permission . text } \" )","title":"get_command_permission_in_guild()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_commands","text":"Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.models.incoming.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"get_commands()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.reset_registration","text":"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Parameters: Name Type Description Default new_bot_token None Description None new_application_id None Description None Returns: Type Description TYPE bool Source code in dispike/main.py def reset_registration ( self , new_bot_token = None , new_application_id = None ): \"\"\"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Args: new_bot_token (None, optional): Description new_application_id (None, optional): Description Returns: TYPE: bool \"\"\" try : if new_bot_token == None : _bot_token = self . _bot_token else : _bot_token = new_bot_token if new_application_id == None : _application_id = self . _application_id else : _application_id = new_application_id self . _registrator = RegisterCommands ( application_id = _application_id , bot_token = _bot_token ) self . _bot_token = _bot_token self . _application_id = _application_id return True except Exception : return False","title":"reset_registration()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.run","text":"Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Port to run the bot over. Defaults to 5000. 5000 Source code in dispike/main.py def run ( self , port : int = 5000 ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Port to run the bot over. Defaults to 5000. \"\"\" uvicorn = self . _return_uvicorn_run_function () uvicorn . run ( app = self . referenced_application , port = port )","title":"run()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.send_deferred_message","text":"Send a deferred message. Parameters: Name Type Description Default original_context IncomingDiscordInteraction The orginal context of the message. required new_message DiscordResponse Message to send. required Source code in dispike/main.py async def send_deferred_message ( self , original_context : \"IncomingDiscordInteraction\" , new_message : \"DiscordResponse\" , ): \"\"\"Send a deferred message. Args: original_context (IncomingDiscordInteraction): The orginal context of the message. new_message (DiscordResponse): Message to send. \"\"\" async with httpx . AsyncClient ( base_url = f \"https://discord.com/api/v8/webhooks/ { self . _application_id } / { original_context . token } /messages/\" , headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) as client : try : # TODO: Probably change later to inside the DeferredResponse? new_message . _switch_to_followup_message () response = await client . patch ( \"/@original\" , data = new_message . response ) response . raise_for_status () except httpx . HTTPError : logger . exception ( f \"Unable to send deferred message with error: { response . text } \" )","title":"send_deferred_message()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.set_command_permission","text":"Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id int Command ID required guild_id int Guild ID required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool [bool]: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id , guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (int): Command ID guild_id (int): Guild ID new_permissions (NewApplicationPermission): Permissions for this command. Returns: [bool]: True, if the command has been successfully edited. \"\"\" with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False","title":"set_command_permission()"},{"location":"APIRef/EventHandler/","text":"\u00b6 A relatively simple \"event handler\". Pass in async functions and provide a string, and it will call it Attributes: Name Type Description callbacks dict dict of names --> functions check_event_exists ( self , event ) \u00b6 Checks if the event in .callbacks Parameters: Name Type Description Default event str event name required Returns: Type Description bool bool: returns if the event is in callbacks. Source code in dispike/eventer.py def check_event_exists ( self , event : str ) -> bool : \"\"\"Checks if the event in ``.callbacks`` Args: event (str): event name Returns: bool: returns if the event is in callbacks. \"\"\" return event in self . callbacks emit ( self , event , * args , ** kwargs ) async \u00b6 'Emits' an event. It will basically call the function from .callbacks and return the function result Parameters: Name Type Description Default event str Event name required *args extra arguments to pass () **kwargs extra kwargs to pass {} Returns: Type Description function result returns the function result Exceptions: Type Description TypeError raises if event is not registered. Source code in dispike/eventer.py async def emit ( self , event : str , * args , ** kwargs ): \"\"\"'Emits' an event. It will basically call the function from .callbacks and return the function result Args: event (str): Event name *args: extra arguments to pass **kwargs: extra kwargs to pass Returns: function result: returns the function result Raises: TypeError: raises if event is not registered. \"\"\" if event not in self . callbacks : raise TypeError ( f \"event { event } does not have a corresponding handler. Did you register this function/event?\" ) _look_up_function = self . return_event_function ( event ) return await _look_up_function ( ** kwargs ) on ( self , event , func = None ) \u00b6 A wrapper over an async function, registers it in .callbacks. Parameters: Name Type Description Default event str Event name required func Callable function to wrap around None Returns: Type Description <function> returns the wrapped function Source code in dispike/eventer.py def on ( self , event : str , func : typing . Callable = None , ): \"\"\"A wrapper over an async function, registers it in .callbacks. Args: event (str): Event name func (None, optional): function to wrap around Returns: <function>: returns the wrapped function \"\"\" def on ( func ): if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Function must be a async function.\" ) if event not in self . callbacks : logger . debug ( f \"Added { event } to corresponding function to { func } \" ) self . callbacks [ event ] = { \"settings\" : {}, \"function\" : func , } else : raise TypeError ( \"Events can only have one corresponding handler.\" ) return func return on ( func ) if func else on view_event_function_return_type ( self , event ) \u00b6 Get type hint for event functions Parameters: Name Type Description Default event str Event name required Returns: Type Description dict dict: Returns .get_type_hints for event Source code in dispike/eventer.py def view_event_function_return_type ( self , event : str ) -> dict : \"\"\"Get type hint for event functions Args: event (str): Event name Returns: dict: Returns .get_type_hints for event \"\"\" return typing . get_type_hints ( self . callbacks [ event ][ \"function\" ])","title":"EventHandler"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler","text":"A relatively simple \"event handler\". Pass in async functions and provide a string, and it will call it Attributes: Name Type Description callbacks dict dict of names --> functions","title":"dispike.eventer.EventHandler"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.check_event_exists","text":"Checks if the event in .callbacks Parameters: Name Type Description Default event str event name required Returns: Type Description bool bool: returns if the event is in callbacks. Source code in dispike/eventer.py def check_event_exists ( self , event : str ) -> bool : \"\"\"Checks if the event in ``.callbacks`` Args: event (str): event name Returns: bool: returns if the event is in callbacks. \"\"\" return event in self . callbacks","title":"check_event_exists()"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.emit","text":"'Emits' an event. It will basically call the function from .callbacks and return the function result Parameters: Name Type Description Default event str Event name required *args extra arguments to pass () **kwargs extra kwargs to pass {} Returns: Type Description function result returns the function result Exceptions: Type Description TypeError raises if event is not registered. Source code in dispike/eventer.py async def emit ( self , event : str , * args , ** kwargs ): \"\"\"'Emits' an event. It will basically call the function from .callbacks and return the function result Args: event (str): Event name *args: extra arguments to pass **kwargs: extra kwargs to pass Returns: function result: returns the function result Raises: TypeError: raises if event is not registered. \"\"\" if event not in self . callbacks : raise TypeError ( f \"event { event } does not have a corresponding handler. Did you register this function/event?\" ) _look_up_function = self . return_event_function ( event ) return await _look_up_function ( ** kwargs )","title":"emit()"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.on","text":"A wrapper over an async function, registers it in .callbacks. Parameters: Name Type Description Default event str Event name required func Callable function to wrap around None Returns: Type Description <function> returns the wrapped function Source code in dispike/eventer.py def on ( self , event : str , func : typing . Callable = None , ): \"\"\"A wrapper over an async function, registers it in .callbacks. Args: event (str): Event name func (None, optional): function to wrap around Returns: <function>: returns the wrapped function \"\"\" def on ( func ): if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Function must be a async function.\" ) if event not in self . callbacks : logger . debug ( f \"Added { event } to corresponding function to { func } \" ) self . callbacks [ event ] = { \"settings\" : {}, \"function\" : func , } else : raise TypeError ( \"Events can only have one corresponding handler.\" ) return func return on ( func ) if func else on","title":"on()"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.view_event_function_return_type","text":"Get type hint for event functions Parameters: Name Type Description Default event str Event name required Returns: Type Description dict dict: Returns .get_type_hints for event Source code in dispike/eventer.py def view_event_function_return_type ( self , event : str ) -> dict : \"\"\"Get type hint for event functions Args: event (str): Event name Returns: dict: Returns .get_type_hints for event \"\"\" return typing . get_type_hints ( self . callbacks [ event ][ \"function\" ])","title":"view_event_function_return_type()"},{"location":"APIRef/RegCommands/","text":"\u00b6 This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async. bot_token property writable \u00b6 You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value request_headers property readonly \u00b6 Return a valid header for authorization Returns: Type Description dict a valid header for authorization __init__ ( self , application_id , bot_token ) special \u00b6 Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/register/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" ) register ( self , command , guild_only = False , guild_to_target = None ) \u00b6 Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"RegisterCommands"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands","text":"This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async.","title":"dispike.register.registrator.RegisterCommands"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.bot_token","text":"You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value","title":"bot_token"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.request_headers","text":"Return a valid header for authorization Returns: Type Description dict a valid header for authorization","title":"request_headers"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.__init__","text":"Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/register/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" )","title":"__init__()"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"register()"},{"location":"CreatingCommands/standard/","text":"Standard Commands \u00b6 Creating standard commands is easy to create, and follows a similar structure to building it in JSON. Dispike assists you in creating a valid JSON, and will provide auto-completion and type hints. from dispike.register.models import ( DiscordCommand , CommandChoice , CommandOption , CommandTypes , ) instant_response_command = DiscordCommand ( name = \"quote\" , description = \"Return a quote from a world leader.\" , options = [ CommandOption ( name = \"worldleader\" , description = \"World leader name\" , required = True , type = CommandTypes . STRING , choices = [ CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), ], ) ], ) Above example will create a command /quote <worldleader>:{list of chocies} A list of choices will presented to the users. CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), Your handler will recieve the value of the choice. Not the name . Meaning if I chose Chancellor Angela Merkel , my bot would recieve merkel .","title":"Standard Commands"},{"location":"CreatingCommands/standard/#standard-commands","text":"Creating standard commands is easy to create, and follows a similar structure to building it in JSON. Dispike assists you in creating a valid JSON, and will provide auto-completion and type hints. from dispike.register.models import ( DiscordCommand , CommandChoice , CommandOption , CommandTypes , ) instant_response_command = DiscordCommand ( name = \"quote\" , description = \"Return a quote from a world leader.\" , options = [ CommandOption ( name = \"worldleader\" , description = \"World leader name\" , required = True , type = CommandTypes . STRING , choices = [ CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), ], ) ], ) Above example will create a command /quote <worldleader>:{list of chocies} A list of choices will presented to the users. CommandChoice ( name = \"President Donald J. Trump\" , value = \"donaldtrump\" ), CommandChoice ( name = \"President Xi Jinping\" , value = \"xi\" ), CommandChoice ( name = \"Prime Minster Boris Johnson\" , value = \"boris\" ), CommandChoice ( name = \"Chancellor Angela Merkel\" , value = \"merkel\" ), CommandChoice ( name = \"Prime Minster Yoshihide Suga\" , value = \"suga\" ), CommandChoice ( name = \"Prime Minster Jacinda Ardern\" , value = \"ardern\" ), Your handler will recieve the value of the choice. Not the name . Meaning if I chose Chancellor Angela Merkel , my bot would recieve merkel .","title":"Standard Commands"},{"location":"CreatingCommands/subcommands/","text":"Subcommands \u00b6 Subcommands are a more advanced form of creating bots, and it's recommended that you read the discord documentation before coming here. Subcommands follow a similar structure as standard commands. later_response_command = DiscordCommand ( name = \"news\" , description = \"Get news!\" , options = [ CommandOption ( name = \"top\" , description = \"Get the top news.\" , type = 1 , options = [ CommandOption ( name = \"Country\" , description = \"Get news for a country!\" , type = CommandTypes . STRING , required = False , choices = [ CommandChoice ( name = \"United States\" , value = \"us\" ), CommandChoice ( name = \"Canada\" , value = \"ca\" ), CommandChoice ( name = \"Australia\" , value = \"au\" ), CommandChoice ( name = \"United Kingdom\" , value = \"gb\" ), CommandChoice ( name = \"France\" , value = \"fr\" ), CommandChoice ( name = \"South Korea\" , value = \"kr\" ), CommandChoice ( name = \"Germany\" , value = \"de\" ), ], ), ], ) ], ) Info Notice the structure, it's more \"nested\". The Discord documentation has a diagram explaining the correct structure. Above example will create /news top <country> Warning Remember to properly write your handler to account for optional arguments. [TODO: Add example code for subcommands]","title":"Subcommands"},{"location":"CreatingCommands/subcommands/#subcommands","text":"Subcommands are a more advanced form of creating bots, and it's recommended that you read the discord documentation before coming here. Subcommands follow a similar structure as standard commands. later_response_command = DiscordCommand ( name = \"news\" , description = \"Get news!\" , options = [ CommandOption ( name = \"top\" , description = \"Get the top news.\" , type = 1 , options = [ CommandOption ( name = \"Country\" , description = \"Get news for a country!\" , type = CommandTypes . STRING , required = False , choices = [ CommandChoice ( name = \"United States\" , value = \"us\" ), CommandChoice ( name = \"Canada\" , value = \"ca\" ), CommandChoice ( name = \"Australia\" , value = \"au\" ), CommandChoice ( name = \"United Kingdom\" , value = \"gb\" ), CommandChoice ( name = \"France\" , value = \"fr\" ), CommandChoice ( name = \"South Korea\" , value = \"kr\" ), CommandChoice ( name = \"Germany\" , value = \"de\" ), ], ), ], ) ], ) Info Notice the structure, it's more \"nested\". The Discord documentation has a diagram explaining the correct structure. Above example will create /news top <country> Warning Remember to properly write your handler to account for optional arguments. [TODO: Add example code for subcommands]","title":"Subcommands"},{"location":"DeletingCommands/","text":"Deleting Commands \u00b6 Deleting commands is similar to Editing Commands except the new_command parameter is not available. Simply pass the command id instead. Pair this with getting commands and you should be good to go in finding what specific commands to delete. from dispike import Dispike bot = Dispike ( ... ) bot . delete_command ( command_id = 12345 ) API Reference \u00b6 \u00b6 Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id int Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def delete_command ( self , command_id : int , guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (int): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"Deleting Commands"},{"location":"DeletingCommands/#deleting-commands","text":"Deleting commands is similar to Editing Commands except the new_command parameter is not available. Simply pass the command id instead. Pair this with getting commands and you should be good to go in finding what specific commands to delete. from dispike import Dispike bot = Dispike ( ... ) bot . delete_command ( command_id = 12345 )","title":"Deleting Commands"},{"location":"DeletingCommands/#api-reference","text":"","title":"API Reference"},{"location":"DeletingCommands/#dispike.main.Dispike.delete_command","text":"Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id int Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise an error will be raised. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def delete_command ( self , command_id : int , guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (int): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise an error will be raised. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"dispike.main.Dispike.delete_command"},{"location":"DeployingToProduction/","text":"Deploying to Production \u00b6 After completing development of your bot, and fully tested it in a controlled environment.. It's time to deploy it and allow requests from Discord. For security reasons, Dispike does not allow you to bind to any other address other than local . This means that no one can access your bot unless it's coming from the machine itself. I highly recommend that you deploy behind a reverse proxy . Not deploying behind a reverse proxy can result in degradation of user experience, security intrusions, etc. There are sample configurations provided here that can be used as a starting point for configuring your reverse proxy correctly. This guide will also provide links to some production-ready configurations for the most popular servers out there. Otherwise, it's recommended to read through the whole guide to understand -- and ultimately build the perfect configuration for your bot. Info View a problem with a sample configuration? Proficient in a different reverse proxy server and don't see a configuration? Contribute to the docs to help out your fellow colleagues! Do I Need to use a Reverse Proxy? \u00b6 99% of the time, it's the best choice. If your cloud provider/deployment service already provides services for load balancing and security Warning Google Cloud App Engine and AWS Elastic Beanstalk =/= the typical servers that are under the same companies. These are specialized services that facilitate things like load balancing. It's time to configure your workers.","title":"Deploying to Production"},{"location":"DeployingToProduction/#deploying-to-production","text":"After completing development of your bot, and fully tested it in a controlled environment.. It's time to deploy it and allow requests from Discord. For security reasons, Dispike does not allow you to bind to any other address other than local . This means that no one can access your bot unless it's coming from the machine itself. I highly recommend that you deploy behind a reverse proxy . Not deploying behind a reverse proxy can result in degradation of user experience, security intrusions, etc. There are sample configurations provided here that can be used as a starting point for configuring your reverse proxy correctly. This guide will also provide links to some production-ready configurations for the most popular servers out there. Otherwise, it's recommended to read through the whole guide to understand -- and ultimately build the perfect configuration for your bot. Info View a problem with a sample configuration? Proficient in a different reverse proxy server and don't see a configuration? Contribute to the docs to help out your fellow colleagues!","title":"Deploying to Production"},{"location":"DeployingToProduction/#do-i-need-to-use-a-reverse-proxy","text":"99% of the time, it's the best choice. If your cloud provider/deployment service already provides services for load balancing and security Warning Google Cloud App Engine and AWS Elastic Beanstalk =/= the typical servers that are under the same companies. These are specialized services that facilitate things like load balancing. It's time to configure your workers.","title":"Do I Need to use a Reverse Proxy?"},{"location":"DeployingToProduction/DeployingWithoutServer/","text":"Deploying Without A Reverse Proxy Server \u00b6 Warning This is not recommended unless your cloud provider/deployment service provides this already. Sample Bot File \u00b6 from dispike import Dispike bot = Dispike ( ... ) Running bot with Uvicorn \u00b6 Installing Uvicorn \u00b6 $ pip install uvicorn [ standard ] ---> 100% Running the bot on a specific port + allowing outside connections. \u00b6 $ uvicorn file_containing_bot:bot.referenced_application --host 0 .0.0.0 --port 443 <span style=\"color: green;\">INFO</span>: Uvicorn running on http://0.0.0.0:443 (Press CTRL+C to quit) .referenced_application is extremely important. Running bot with Hypercorn \u00b6 $ pip install hypercorn ---> 100% Running the bot on a specific port + allowing outside connections. \u00b6 $ hypercorn file_containing_bot:bot.referenced_application --bind 0 .0.0.0:443 Running on 0.0.0.0:8080 over http (CTRL + C to quit) .referenced_application is extremely important. Important notes \u00b6 You may need to bind to 443 -- as discord requires HTTPS.","title":"DeployingWithoutServer"},{"location":"DeployingToProduction/DeployingWithoutServer/#deploying-without-a-reverse-proxy-server","text":"Warning This is not recommended unless your cloud provider/deployment service provides this already.","title":"Deploying Without A Reverse Proxy Server"},{"location":"DeployingToProduction/DeployingWithoutServer/#sample-bot-file","text":"from dispike import Dispike bot = Dispike ( ... )","title":"Sample Bot File"},{"location":"DeployingToProduction/DeployingWithoutServer/#running-bot-with-uvicorn","text":"","title":"Running bot with Uvicorn"},{"location":"DeployingToProduction/DeployingWithoutServer/#installing-uvicorn","text":"$ pip install uvicorn [ standard ] ---> 100%","title":"Installing Uvicorn"},{"location":"DeployingToProduction/DeployingWithoutServer/#running-the-bot-on-a-specific-port-allowing-outside-connections","text":"$ uvicorn file_containing_bot:bot.referenced_application --host 0 .0.0.0 --port 443 <span style=\"color: green;\">INFO</span>: Uvicorn running on http://0.0.0.0:443 (Press CTRL+C to quit) .referenced_application is extremely important.","title":"Running the bot on a specific port + allowing outside connections."},{"location":"DeployingToProduction/DeployingWithoutServer/#running-bot-with-hypercorn","text":"$ pip install hypercorn ---> 100%","title":"Running bot with Hypercorn"},{"location":"DeployingToProduction/DeployingWithoutServer/#running-the-bot-on-a-specific-port-allowing-outside-connections_1","text":"$ hypercorn file_containing_bot:bot.referenced_application --bind 0 .0.0.0:443 Running on 0.0.0.0:8080 over http (CTRL + C to quit) .referenced_application is extremely important.","title":"Running the bot on a specific port + allowing outside connections."},{"location":"DeployingToProduction/DeployingWithoutServer/#important-notes","text":"You may need to bind to 443 -- as discord requires HTTPS.","title":"Important notes"},{"location":"DeployingToProduction/SettingUpWorkers/","text":"Setting up your workers. \u00b6 Dispike is powered by FastAPI, which in turn is powered by Starlette. This is a AGSI server that must","title":"Setting up your workers."},{"location":"DeployingToProduction/SettingUpWorkers/#setting-up-your-workers","text":"Dispike is powered by FastAPI, which in turn is powered by Starlette. This is a AGSI server that must","title":"Setting up your workers."},{"location":"EditingCommands/","text":"Editing Commands \u00b6 Editing commands require an already initialized Dispike instance and are available as a method provided by Dispike . Bulk editing is available by setting the bulk parameter to True and passing a list of DiscordCommand to the new_command parameter. Editing a single command can be done by passing a DiscordCommand to new_command and specifying the target command ID. Guild-level editing command is available by configuring parameters guild_only -> True guild_id_passed -> GUILD ID Info Follow this Discord guide to find your server/guild ID from dispike import Dispike from dispike.register.models import ( DiscordCommand ) bot = Dispike ( ... ) bot . edit_command ( new_command = DiscordCommand ( ... ), command_id = 12345 ) from dispike import Dispike from dispike.register.models import DiscordCommand bot = Dispike ( ... ) edit_bulk_commands = [ DiscordCommand ( ... ), DiscordCommand ( ... )] bot . edit_command ( new_command = edit_bulk_commands , bulk = True ) API Reference \u00b6 \u00b6 Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id int Command ID None new_command Union[List[dispike.register.models.options.DiscordCommand], dispike.register.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : int = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk == True : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk == True : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False Handling Permissions \u00b6 Permissions are a new feature in Discord that allow bot developers to add permissions for a command. Dispike can help you - View permissions for a command in a guild. - Craft the correct syntax for setting a permission (or multiple) for a command. Preface \u00b6 It's helpful that you read the documentation for Discord to understand how to craft permissions. . Not reading the documentation may result in you creating dangerous commands for a server! Getting Started \u00b6 Import the following: from dispike.register.models.permissions import ( ApplicationCommandPermissions , NewApplicationPermission , ApplicationCommandPermissionType , ) Sample Code \u00b6 new_permission = NewApplicationPermission ( permissions = [ ApplicationCommandPermissions ( id = \"<Discord User Id>\" , type = ApplicationCommandPermissionType . USER , permission = True , # Whether to determine if the user has permission. ) ] ) get_commands = bot . get_commands ( guild_only = True , guild_id_passed = \"<Guild ID>\" ) selected_command = get_commands [ 0 ] update_permission_for_command = bot . set_command_permission ( command_id = selected_command . id # also can be passed manually guild_id = \"<Guild ID>\" , new_permission ) print ( update_permission_for_command ) >> True The example above starts out with creating a new command using NewApplicationPermission . If you read the documentation, it should look familiar to the example provided by Discord -- except for the type that is passed. You can manually use a normal int value for type parameter, otherwise you can use a helper class called ApplicationCommandPermissionType . \u00b6 The permission type of the Application Command. Info \u200b Remember -- You are able to have multiple permissions as the permissions parameter is a List . However you should note Discord's docs about how certain permissions may conflict and throw an error. In a future version dispike may alert you of offending permissions, but for now keep in mind. Afterwards, we need a command to edit, we check this by gathering every command in a guild. If you are not familiar with this, you can read more here . There is a function available in the bot instance that will allow you to update a commands permission. This function is also available in sync & async. \u00b6 Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id int Command ID required guild_id int Guild ID required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool [bool]: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id , guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (int): Command ID guild_id (int): Guild ID new_permissions (NewApplicationPermission): Permissions for this command. Returns: [bool]: True, if the command has been successfully edited. \"\"\" with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False","title":"Editing Commands"},{"location":"EditingCommands/#editing-commands","text":"Editing commands require an already initialized Dispike instance and are available as a method provided by Dispike . Bulk editing is available by setting the bulk parameter to True and passing a list of DiscordCommand to the new_command parameter. Editing a single command can be done by passing a DiscordCommand to new_command and specifying the target command ID. Guild-level editing command is available by configuring parameters guild_only -> True guild_id_passed -> GUILD ID Info Follow this Discord guide to find your server/guild ID from dispike import Dispike from dispike.register.models import ( DiscordCommand ) bot = Dispike ( ... ) bot . edit_command ( new_command = DiscordCommand ( ... ), command_id = 12345 ) from dispike import Dispike from dispike.register.models import DiscordCommand bot = Dispike ( ... ) edit_bulk_commands = [ DiscordCommand ( ... ), DiscordCommand ( ... )] bot . edit_command ( new_command = edit_bulk_commands , bulk = True )","title":"Editing Commands"},{"location":"EditingCommands/#api-reference","text":"","title":"API Reference"},{"location":"EditingCommands/#dispike.main.Dispike.edit_command","text":"Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id int Command ID None new_command Union[List[dispike.register.models.options.DiscordCommand], dispike.register.models.options.DiscordCommand] A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed bool guild id if guild_only is set to True. Defaults to None. False bulk bool Whether to specifiy if this action will be a bulk action. False Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def edit_command ( self , new_command : typing . Union [ typing . List [ DiscordCommand ], DiscordCommand ], command_id : int = None , bulk = False , guild_only = False , guild_id_passed = False , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command ([DiscordCommand, List[DiscordCommand]]): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed (bool, optional): guild id if guild_only is set to True. Defaults to None. bulk (bool, optional): Whether to specifiy if this action will be a bulk action. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if not isinstance ( new_command , ( DiscordCommand , dict , list )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only set to True and NOT pass any guild id.\" ) if bulk == True : _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = \"/commands\" if bulk == True and isinstance ( new_command , list ): _new_command = [ command . dict () for command in new_command ] _selected_request_method = \"PUT\" else : _new_command = new_command . dict () _selected_request_method = \"PATCH\" try : _send_request = self . _registrator . _client . request ( method = _selected_request_method , url = _url , headers = self . _registrator . request_headers , json = _new_command , ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) if bulk == True : return [ DiscordCommand ( ** x ) for x in _send_request . json ()] else : return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False","title":"dispike.main.Dispike.edit_command"},{"location":"EditingCommands/#handling-permissions","text":"Permissions are a new feature in Discord that allow bot developers to add permissions for a command. Dispike can help you - View permissions for a command in a guild. - Craft the correct syntax for setting a permission (or multiple) for a command.","title":"Handling Permissions"},{"location":"EditingCommands/#preface","text":"It's helpful that you read the documentation for Discord to understand how to craft permissions. . Not reading the documentation may result in you creating dangerous commands for a server!","title":"Preface"},{"location":"EditingCommands/#getting-started","text":"Import the following: from dispike.register.models.permissions import ( ApplicationCommandPermissions , NewApplicationPermission , ApplicationCommandPermissionType , )","title":"Getting Started"},{"location":"EditingCommands/#sample-code","text":"new_permission = NewApplicationPermission ( permissions = [ ApplicationCommandPermissions ( id = \"<Discord User Id>\" , type = ApplicationCommandPermissionType . USER , permission = True , # Whether to determine if the user has permission. ) ] ) get_commands = bot . get_commands ( guild_only = True , guild_id_passed = \"<Guild ID>\" ) selected_command = get_commands [ 0 ] update_permission_for_command = bot . set_command_permission ( command_id = selected_command . id # also can be passed manually guild_id = \"<Guild ID>\" , new_permission ) print ( update_permission_for_command ) >> True The example above starts out with creating a new command using NewApplicationPermission . If you read the documentation, it should look familiar to the example provided by Discord -- except for the type that is passed. You can manually use a normal int value for type parameter, otherwise you can use a helper class called ApplicationCommandPermissionType .","title":"Sample Code"},{"location":"EditingCommands/#dispike.register.models.permissions.ApplicationCommandPermissionType","text":"The permission type of the Application Command. Info \u200b Remember -- You are able to have multiple permissions as the permissions parameter is a List . However you should note Discord's docs about how certain permissions may conflict and throw an error. In a future version dispike may alert you of offending permissions, but for now keep in mind. Afterwards, we need a command to edit, we check this by gathering every command in a guild. If you are not familiar with this, you can read more here . There is a function available in the bot instance that will allow you to update a commands permission. This function is also available in sync & async.","title":"dispike.register.models.permissions.ApplicationCommandPermissionType"},{"location":"EditingCommands/#dispike.main.Dispike.set_command_permission","text":"Set a permissions for a command in a specific guild. This function is sync! Parameters: Name Type Description Default command_id int Command ID required guild_id int Guild ID required new_permissions NewApplicationPermission Permissions for this command. required Returns: Type Description bool [bool]: True, if the command has been successfully edited. Source code in dispike/main.py def set_command_permission ( self , command_id , guild_id , new_permissions : \"NewApplicationPermission\" ) -> bool : \"\"\"Set a permissions for a command in a specific guild. This function is sync! Args: command_id (int): Command ID guild_id (int): Guild ID new_permissions (NewApplicationPermission): Permissions for this command. Returns: [bool]: True, if the command has been successfully edited. \"\"\" with httpx . Client () as client : try : _set_command_permissions = client . put ( f \"https://discord.com/api/v8/applications/ { self . _application_id } /guilds/ { guild_id } /commands/ { command_id } /permissions\" , json = new_permissions . dict (), headers = { \"Authorization\" : f \"Bot { self . _bot_token } \" }, ) _set_command_permissions . raise_for_status () return True except httpx . HTTPError : logger . exception ( f \"Unable to set permission for command { command_id } for guild { guild_id } \" ) logger . debug ( f \"request: { _set_command_permissions . status_code } : { _set_command_permissions . text } \" ) return False","title":"dispike.main.Dispike.set_command_permission"},{"location":"GettingCommands/","text":"Getting Commands \u00b6 Getting commands is similar to Editing Commands except for new_command , command_id , parameters are not available. from dispike import Dispike bot = Dispike ( ... ) commands = bot . get_commands () >>> [ IncomingApplicationCommand ( ... ), IncomingApplicationCommand ( ... )] API Reference \u00b6 \u00b6 Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.models.incoming.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"Getting Commands"},{"location":"GettingCommands/#getting-commands","text":"Getting commands is similar to Editing Commands except for new_command , command_id , parameters are not available. from dispike import Dispike bot = Dispike ( ... ) commands = bot . get_commands () >>> [ IncomingApplicationCommand ( ... ), IncomingApplicationCommand ( ... )]","title":"Getting Commands"},{"location":"GettingCommands/#api-reference","text":"","title":"API Reference"},{"location":"GettingCommands/#dispike.main.Dispike.get_commands","text":"Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.models.incoming.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False or not isinstance ( guild_id_passed , str ): raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"dispike.main.Dispike.get_commands"},{"location":"Models/","text":"Models \u00b6 Models are responses or requests to and from Discord that have been verified. Data can be accessed in a pythonic way of attributes rather than dictionaries. Info If you want a more low-level or want to transport models (pickling) you can access attributes .to_dict or .to_json . Models have been split into sections. - Incoming - Outgoing Outgoing models are usually created by the user and meant to be sent to Discord, and have the strictest validation. They are easily editable by property. Incoming models are usually models that have been translated from Discord themselves and have been validated. While it's possible to edit the attributes, no function provided by Dispike will accept them. Treat them as read-only. Info in certain circumstances, you can convert Incoming models to Outgoing, simply pass .to_dict of the incoming object to the appropriate outgoing object by doing OutgoingObject(**IncomingObject) .","title":"Info"},{"location":"Models/#models","text":"Models are responses or requests to and from Discord that have been verified. Data can be accessed in a pythonic way of attributes rather than dictionaries. Info If you want a more low-level or want to transport models (pickling) you can access attributes .to_dict or .to_json . Models have been split into sections. - Incoming - Outgoing Outgoing models are usually created by the user and meant to be sent to Discord, and have the strictest validation. They are easily editable by property. Incoming models are usually models that have been translated from Discord themselves and have been validated. While it's possible to edit the attributes, no function provided by Dispike will accept them. Treat them as read-only. Info in certain circumstances, you can convert Incoming models to Outgoing, simply pass .to_dict of the incoming object to the appropriate outgoing object by doing OutgoingObject(**IncomingObject) .","title":"Models"},{"location":"Models/Incoming/","text":"Incoming Objects \u00b6 \u00b6 IncomingApplicationCommand pydantic-model \u00b6 an Incoming Application command, this is not intended for you to edit, and will not be accepted in any function IncomingDiscordInteraction pydantic-model \u00b6 An incoming discord interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. IncomingDiscordOption pydantic-model \u00b6 An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand IncomingDiscordOptionList pydantic-model \u00b6 An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand InteractionType \u00b6 An enumeration. SubcommandIncomingDiscordOptionList pydantic-model \u00b6 An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand","title":"Incoming"},{"location":"Models/Incoming/#incoming-objects","text":"","title":"Incoming Objects"},{"location":"Models/Incoming/#dispike.models.incoming","text":"","title":"dispike.models.incoming"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingApplicationCommand","text":"an Incoming Application command, this is not intended for you to edit, and will not be accepted in any function","title":"IncomingApplicationCommand"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingDiscordInteraction","text":"An incoming discord interaction, this is not intended for you to edit, and will not be accepted as an argument in any function.","title":"IncomingDiscordInteraction"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingDiscordOption","text":"An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand","title":"IncomingDiscordOption"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingDiscordOptionList","text":"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand","title":"IncomingDiscordOptionList"},{"location":"Models/Incoming/#dispike.models.incoming.InteractionType","text":"An enumeration.","title":"InteractionType"},{"location":"Models/Incoming/#dispike.models.incoming.SubcommandIncomingDiscordOptionList","text":"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand","title":"SubcommandIncomingDiscordOptionList"},{"location":"Models/Outgoing/","text":"Outgoing Models \u00b6 To import these models from dispike.register.models.options import < Object > Warning Version >=v0.5.7a adds support for VSCode to auto-complete attributes when creating these models. \u00b6 CommandChoice pydantic-model \u00b6 Represents a key-value command choice. CommandOption pydantic-model \u00b6 Represents a standard command option (not a subcommand). CommandTypes \u00b6 Easy access to command types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 MENTIONABLE int Represents Type 9 DiscordCommand pydantic-model \u00b6 Represents a discord command. SubcommandOption pydantic-model \u00b6 Represents a subcommand group usually you would put this as an option in a DiscordCommand","title":"Outgoing"},{"location":"Models/Outgoing/#outgoing-models","text":"To import these models from dispike.register.models.options import < Object > Warning Version >=v0.5.7a adds support for VSCode to auto-complete attributes when creating these models.","title":"Outgoing Models"},{"location":"Models/Outgoing/#dispike.register.models.options","text":"","title":"dispike.register.models.options"},{"location":"Models/Outgoing/#dispike.register.models.options.CommandChoice","text":"Represents a key-value command choice.","title":"CommandChoice"},{"location":"Models/Outgoing/#dispike.register.models.options.CommandOption","text":"Represents a standard command option (not a subcommand).","title":"CommandOption"},{"location":"Models/Outgoing/#dispike.register.models.options.CommandTypes","text":"Easy access to command types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 MENTIONABLE int Represents Type 9","title":"CommandTypes"},{"location":"Models/Outgoing/#dispike.register.models.options.DiscordCommand","text":"Represents a discord command.","title":"DiscordCommand"},{"location":"Models/Outgoing/#dispike.register.models.options.SubcommandOption","text":"Represents a subcommand group usually you would put this as an option in a DiscordCommand","title":"SubcommandOption"},{"location":"Models/Read%20Only/Incoming/","text":"from enum import Enum from pydantic import BaseModel , Json , ValidationError , validator import typing from .discord_types.member import Member from .discord_types.component import ComponentType from ..register.models import CommandOption , SubcommandOption try : from typing import Literal # pragma: no cover except ImportError : # pragma: no cover # backport from typing_extensions import Literal # pragma: no cover class InteractionType ( int , Enum ): APPLICATION_COMMAND = 2 MESSAGE_COMPONENT = 3 class IncomingDiscordOption ( BaseModel ): \"\"\"An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand \"\"\" name : str value : str class SubcommandIncomingDiscordOptionListChild ( BaseModel ): class Config : arbitary_types_allowed = True name : str options : typing . List [ IncomingDiscordOption ] class SubcommandIncomingDiscordOptionList ( BaseModel ): \"\"\"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand \"\"\" class Config : arbitary_types_allowed = True name : str options : typing . Union [ typing . List [ IncomingDiscordOption ], typing . List [ SubcommandIncomingDiscordOptionListChild ], ] class IncomingDiscordOptionList ( BaseModel ): \"\"\"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand \"\"\" class Config : arbitary_types_allowed = True id : str name : str options : typing . Optional [ typing . Union [ typing . List [ IncomingDiscordOption ], typing . List [ SubcommandIncomingDiscordOptionList ], ] ] = None class IncomingDiscordInteraction ( BaseModel ): \"\"\"An incoming discord interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. \"\"\" class Config : arbitary_types_allowed = True type : InteractionType # 1 is removed, this lib will handle PING id : int data : IncomingDiscordOptionList guild_id : int channel_id : int member : Member token : str version : typing . Optional [ Literal [ 1 ]] = None channel_id : int class IncomingApplicationCommand ( BaseModel ): \"\"\"an Incoming Application command, this is not intended for you to edit, and will not be accepted in any function \"\"\" class Config : arbitary_types_allowed = True id : int application_id : int name : str description : str options : typing . Optional [ typing . Union [ typing . List [ CommandOption ], typing . List [ SubcommandOption ]] ] default_permission : typing . Optional [ bool ] # ? not listed in docs but appears in request version : typing . Optional [ str ] class SelectedButtonInteractionData ( BaseModel ): custom_id : typing . Union [ int , str ] component_type : Literal [ ComponentType . BUTTON ] class IncomingButtonInteraction ( BaseModel ): class Config : arbitary_types_allowed = True type : Literal [ InteractionType . MESSAGE_COMPONENT ] # 1 is removed, this lib will handle PING id : int guild_id : int channel_id : int member : Member token : str version : typing . Optional [ Literal [ 1 ]] = None channel_id : int message : typing . Union [ dict , Json ] # TODO: Create BaseModel for Discord Messages data : SelectedButtonInteractionData","title":"Incoming"},{"location":"responses/","text":"Responses \u00b6 Responses are what are returned to Discord. To create a proper response, you will need the DiscordResponse object. \u200b","title":"Info"},{"location":"responses/#responses","text":"Responses are what are returned to Discord. To create a proper response, you will need the DiscordResponse object. \u200b","title":"Responses"},{"location":"responses/DeferredMessages/","text":"Deferred Messages \u00b6 Deferred Messages are messages that will appear later to the user. Setting up the handler. \u00b6 Setting up the handler for deferred response commands are a little bit different compared to normal commands. Dispike will automatically run your handler function after responding to Discord. Warning You have 15 Minutes to respond back to Discord before the token expires. Deferred Responses are useful for commands that require background processing that otherwise would lead to an error if it was a standard command. Requirements \u00b6 Your handler must hint a return of DeferredResponse . Any other hinted return (or no hinted return) may result in a delay in your bot responding. When you are ready to send your respond, use the provided function .send_deferred_message in your bot instance. Warning Your handler must still be an async function! @bot . interaction . on ( \"new.code\" ) async def generate_secret_code ( ctx : IncomingDiscordInteraction ) -> DeferredResponse : data = _heavy_function () # Compute-heavy task here. # # Remember that you have 15 minutes to respond before the token # expires.. # await bot . send_deferred_message ( original_context = ctx , new_message = DiscordResponse ( content = \"back with a new response.\" ), )","title":"Deferred Responses"},{"location":"responses/DeferredMessages/#deferred-messages","text":"Deferred Messages are messages that will appear later to the user.","title":"Deferred Messages"},{"location":"responses/DeferredMessages/#setting-up-the-handler","text":"Setting up the handler for deferred response commands are a little bit different compared to normal commands. Dispike will automatically run your handler function after responding to Discord. Warning You have 15 Minutes to respond back to Discord before the token expires. Deferred Responses are useful for commands that require background processing that otherwise would lead to an error if it was a standard command.","title":"Setting up the handler."},{"location":"responses/DeferredMessages/#requirements","text":"Your handler must hint a return of DeferredResponse . Any other hinted return (or no hinted return) may result in a delay in your bot responding. When you are ready to send your respond, use the provided function .send_deferred_message in your bot instance. Warning Your handler must still be an async function! @bot . interaction . on ( \"new.code\" ) async def generate_secret_code ( ctx : IncomingDiscordInteraction ) -> DeferredResponse : data = _heavy_function () # Compute-heavy task here. # # Remember that you have 15 minutes to respond before the token # expires.. # await bot . send_deferred_message ( original_context = ctx , new_message = DiscordResponse ( content = \"back with a new response.\" ), )","title":"Requirements"},{"location":"responses/readyresponse/","text":"Ready Response \u00b6 The DiscordResponse is available as a convenience object to assist you in generating a proper payload to return to discord. Some methods and functions may require you to only use a valid DiscordResponse . from dispike.responses import DiscordResponse content , embeds , and tts is not required immediately, and can be configured later. However, settings such as show_user_input and folow_up_message are set at first initialization and cannot be changed. from dispike.responses import DiscordResponse response = DiscordResponse () response . content = \"Content Text Here\" from dispike.responses import DiscordResponse from dispike.helper import Embed async def sample_function ( ... ) -> DiscordResponse : ... return DiscordResponse ( content = \"Content Text Here\" , tts = False , embeds = [ Embed ( ... ), Embed ( ... )], show_user_input = True ) Empherical Messages \u00b6 Empherical messages (messages/responses that are only visible to the person who sent them ) are available by setting the optional empherical parameter to True . Info Setting a response to be empherical after initialization can be done by setting the ._is_empherical attribute. (Note this will be changed in newer versions of Dispike.) from dispike.responses import DiscordResponse response = DiscordResponse ( empherical = True ) response . content = \"Content Text Here\" Info DiscordResponse is simply a helper to help you generate a valid response to discord. If you can generate a valid response yourself, you can simply type-hint your function to hint at a dict and return a proper response. This is only recommended for Advanced users. \u00b6 Represents an outgoing Discord Response Attributes: Name Type Description content str A plain-text response to a user tts bool bool returning if the message should be spoken via tts. embeds dict a List representing .to_dict of an Embed object. response dict a valid response represented in a dict, to later be converted to JSON. content: str property writable \u00b6 Either set or view the plain-text response to the user. Returns: Type Description str str: Content provided embeds: List [ dict ] property readonly \u00b6 Returns a list of embeds to send to. Returns: Type Description List[dict] typing.List[dict]: Embeds represented as a dict. response: dict property readonly \u00b6 A generated valid discord response Returns: Type Description dict dict: a valid discord response. tts: bool property writable \u00b6 Either set or view the tts attribute for the user. Returns: Type Description bool bool: tts __init__ ( self , content = None , tts = False , embeds = [], show_user_input = False , follow_up_message = False , empherical = False , allowed_mentions = None ) special \u00b6 Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Parameters: Name Type Description Default content str A plain-text response to a user None tts bool bool returning if the message should be spoken via tts False embeds List[dispike.helper.embed.Embed] a List representing .to_dict of an Embed object [] show_user_input bool Whether to delete the user's message of calling the command after responding. False empherical bool Whether to send message as an empherical message. False allowed_mentions AllowedMentions Let discord filter mentions per configuration. None Source code in dispike/response.py def __init__ ( self , content : str = None , tts : bool = False , embeds : typing . List [ Embed ] = [], show_user_input : bool = False , follow_up_message = False , empherical = False , allowed_mentions : \"AllowedMentions\" = None , ): \"\"\"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Args: content (str, optional): A plain-text response to a user tts (bool, optional): bool returning if the message should be spoken via tts embeds (typing.List[Embed], optional): a List representing .to_dict of an Embed object show_user_input (bool, optional): Whether to delete the user's message of calling the command after responding. empherical (bool, optional): Whether to send message as an empherical message. allowed_mentions (typing.List[AllowedMentions], optional): Let discord filter mentions per configuration. \"\"\" if content != None : if isinstance ( content , str ) == False : raise TypeError ( f \"Content must be a string\" ) elif content == \"\" : content = None # if isinstance(content, str) == False or content == \"\" or content != None: # raise TypeError(f\"content must be a string. recieved: {content}\") if isinstance ( tts , bool ) == False : raise TypeError ( \"tts must be a bool\" ) self . _content = content self . _tts = tts self . _embeds = [ x . to_dict () for x in embeds ] if show_user_input == False : logger . warning ( \"show_user_input is longer supported by discord.\" ) self . _type_response = 4 else : self . _type_response = 4 self . _is_followup = follow_up_message self . _is_empherical = empherical self . _allowed_mentions = allowed_mentions add_new_embed ( self , embed_to_add ) \u00b6 Append a new embed, provided with a proper Embed object Parameters: Name Type Description Default embed_to_add Embed Proper Embed Object required Exceptions: Type Description TypeError Raised if you do not pass a proper Embed object. Source code in dispike/response.py def add_new_embed ( self , embed_to_add : Embed ): \"\"\"Append a new embed, provided with a proper Embed object Args: embed_to_add (Embed): Proper Embed Object Raises: TypeError: Raised if you do not pass a proper Embed object. \"\"\" if isinstance ( embed_to_add , Embed ): self . _embeds . append ( embed_to_add . to_dict ()) else : raise TypeError ( \"embed must be a Embed object.\" )","title":"Ready Responses"},{"location":"responses/readyresponse/#ready-response","text":"The DiscordResponse is available as a convenience object to assist you in generating a proper payload to return to discord. Some methods and functions may require you to only use a valid DiscordResponse . from dispike.responses import DiscordResponse content , embeds , and tts is not required immediately, and can be configured later. However, settings such as show_user_input and folow_up_message are set at first initialization and cannot be changed. from dispike.responses import DiscordResponse response = DiscordResponse () response . content = \"Content Text Here\" from dispike.responses import DiscordResponse from dispike.helper import Embed async def sample_function ( ... ) -> DiscordResponse : ... return DiscordResponse ( content = \"Content Text Here\" , tts = False , embeds = [ Embed ( ... ), Embed ( ... )], show_user_input = True )","title":"Ready Response"},{"location":"responses/readyresponse/#empherical-messages","text":"Empherical messages (messages/responses that are only visible to the person who sent them ) are available by setting the optional empherical parameter to True . Info Setting a response to be empherical after initialization can be done by setting the ._is_empherical attribute. (Note this will be changed in newer versions of Dispike.) from dispike.responses import DiscordResponse response = DiscordResponse ( empherical = True ) response . content = \"Content Text Here\" Info DiscordResponse is simply a helper to help you generate a valid response to discord. If you can generate a valid response yourself, you can simply type-hint your function to hint at a dict and return a proper response. This is only recommended for Advanced users.","title":"Empherical Messages"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse","text":"Represents an outgoing Discord Response Attributes: Name Type Description content str A plain-text response to a user tts bool bool returning if the message should be spoken via tts. embeds dict a List representing .to_dict of an Embed object. response dict a valid response represented in a dict, to later be converted to JSON.","title":"dispike.response.DiscordResponse"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.content","text":"Either set or view the plain-text response to the user. Returns: Type Description str str: Content provided","title":"content"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.embeds","text":"Returns a list of embeds to send to. Returns: Type Description List[dict] typing.List[dict]: Embeds represented as a dict.","title":"embeds"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.response","text":"A generated valid discord response Returns: Type Description dict dict: a valid discord response.","title":"response"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.tts","text":"Either set or view the tts attribute for the user. Returns: Type Description bool bool: tts","title":"tts"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.__init__","text":"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Parameters: Name Type Description Default content str A plain-text response to a user None tts bool bool returning if the message should be spoken via tts False embeds List[dispike.helper.embed.Embed] a List representing .to_dict of an Embed object [] show_user_input bool Whether to delete the user's message of calling the command after responding. False empherical bool Whether to send message as an empherical message. False allowed_mentions AllowedMentions Let discord filter mentions per configuration. None Source code in dispike/response.py def __init__ ( self , content : str = None , tts : bool = False , embeds : typing . List [ Embed ] = [], show_user_input : bool = False , follow_up_message = False , empherical = False , allowed_mentions : \"AllowedMentions\" = None , ): \"\"\"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Args: content (str, optional): A plain-text response to a user tts (bool, optional): bool returning if the message should be spoken via tts embeds (typing.List[Embed], optional): a List representing .to_dict of an Embed object show_user_input (bool, optional): Whether to delete the user's message of calling the command after responding. empherical (bool, optional): Whether to send message as an empherical message. allowed_mentions (typing.List[AllowedMentions], optional): Let discord filter mentions per configuration. \"\"\" if content != None : if isinstance ( content , str ) == False : raise TypeError ( f \"Content must be a string\" ) elif content == \"\" : content = None # if isinstance(content, str) == False or content == \"\" or content != None: # raise TypeError(f\"content must be a string. recieved: {content}\") if isinstance ( tts , bool ) == False : raise TypeError ( \"tts must be a bool\" ) self . _content = content self . _tts = tts self . _embeds = [ x . to_dict () for x in embeds ] if show_user_input == False : logger . warning ( \"show_user_input is longer supported by discord.\" ) self . _type_response = 4 else : self . _type_response = 4 self . _is_followup = follow_up_message self . _is_empherical = empherical self . _allowed_mentions = allowed_mentions","title":"__init__()"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.add_new_embed","text":"Append a new embed, provided with a proper Embed object Parameters: Name Type Description Default embed_to_add Embed Proper Embed Object required Exceptions: Type Description TypeError Raised if you do not pass a proper Embed object. Source code in dispike/response.py def add_new_embed ( self , embed_to_add : Embed ): \"\"\"Append a new embed, provided with a proper Embed object Args: embed_to_add (Embed): Proper Embed Object Raises: TypeError: Raised if you do not pass a proper Embed object. \"\"\" if isinstance ( embed_to_add , Embed ): self . _embeds . append ( embed_to_add . to_dict ()) else : raise TypeError ( \"embed must be a Embed object.\" )","title":"add_new_embed()"},{"location":"responses/writinghandler/","text":"Preface \u00b6 Writing a handler function is required to properly route interactions from the user to your bot. After request verification, the request (interaction) is passed to an IncomingDiscordInteraction object. You will write your handler as a function to directly accept an additional argument called ctx containing this interaction. It's normal not to use this interaction, it only exists to give you context about the interaction. Writing the handler. \u00b6 Your handler must be Async ( async def ) Accept the same number of arguments (if any) as the command with an additional argument for the context. python async def ...(argument_one, argument_two, ctx) -> ... Contain a bot.interaction.on(<command-identifier>) decorator. Finding the command identifier. \u00b6 Normal commands \u00b6 Finding the command identifier is a simple feat. If you are writing a normal (non-subcommand) command, it's often just the command name. comma n d_ t o_be_regis tere d = DiscordComma n d( na me= \"wave\" , # t his is t he mai n comma n d na me. , descrip t io n = \"Send a wave to a nice person! \ud83d\udc4b \" , op t io ns = [ Comma n dOp t io n ( na me= \"person\" , # t his is t he a ttr ibu te assig ne d t o t he value passed. , descrip t io n = \"person to target\" , # t his describes t he value t o pass , required=True , t ype=Comma n dTypes.USER ) ] ) The command identifier in this case will be wave . @bot . interaction . on ( \"wave\" ) async def handle_wave ( person , ctx ) -> DiscordResponse : ... Subcommands \u00b6 Subcommands are similar but are more \"nested\". Each layer will be represented and separated by a . Take a look at this command that was registered command_configuration = DiscordCommand ( name = \"forex\" , description = \"Get Forex rates\" , options = [ SubcommandOption ( name = \"latest\" , description = \"Get latest forex rates.\" , type = 2 , options = [ CommandOption ( name = \"convert\" , description = \"View rates between two symbols.\" , type = 1 , required = False , options = [ { \"name\" : \"symbol_1\" , \"description\" : \"Symbol 1\" , \"type\" : CommandTypes . STRING , \"required\" : True , }, { \"name\" : \"symbol_2\" , \"description\" : \"Symbol 2\" , \"type\" : CommandTypes . STRING , \"required\" : False , }, ], ) ], ) ], ) When a user uses this command in discord. They'd use it as /forex latest convert <SYMBOL 1> <SYMBOL 2> The command identifier would be represented as forex.latest.convert Defining the arguments \u00b6 You must define the same number of arguments in your python function as the discord command . Warning If you have an optional argument, you can pass the **kwargs argument to your function. Learn more about the *kwargs argument here . If the user adds an optional argument, this will be passed to the function. Otherwise, it will not be present. Write your code to check if it exists before doing anything! The command argument names must match to the one set as the value when registering your command. @bot . interaction . on ( \"forex.latest.convert\" ) async def handle_forex_convert ( symbol_1 : str , symbol_2 : str , ctx : IncomingDiscordInteraction ) -> DiscordResponse : ...","title":"Writing your Handler"},{"location":"responses/writinghandler/#preface","text":"Writing a handler function is required to properly route interactions from the user to your bot. After request verification, the request (interaction) is passed to an IncomingDiscordInteraction object. You will write your handler as a function to directly accept an additional argument called ctx containing this interaction. It's normal not to use this interaction, it only exists to give you context about the interaction.","title":"Preface"},{"location":"responses/writinghandler/#writing-the-handler","text":"Your handler must be Async ( async def ) Accept the same number of arguments (if any) as the command with an additional argument for the context. python async def ...(argument_one, argument_two, ctx) -> ... Contain a bot.interaction.on(<command-identifier>) decorator.","title":"Writing the handler."},{"location":"responses/writinghandler/#finding-the-command-identifier","text":"","title":"Finding the command identifier."},{"location":"responses/writinghandler/#normal-commands","text":"Finding the command identifier is a simple feat. If you are writing a normal (non-subcommand) command, it's often just the command name. comma n d_ t o_be_regis tere d = DiscordComma n d( na me= \"wave\" , # t his is t he mai n comma n d na me. , descrip t io n = \"Send a wave to a nice person! \ud83d\udc4b \" , op t io ns = [ Comma n dOp t io n ( na me= \"person\" , # t his is t he a ttr ibu te assig ne d t o t he value passed. , descrip t io n = \"person to target\" , # t his describes t he value t o pass , required=True , t ype=Comma n dTypes.USER ) ] ) The command identifier in this case will be wave . @bot . interaction . on ( \"wave\" ) async def handle_wave ( person , ctx ) -> DiscordResponse : ...","title":"Normal commands"},{"location":"responses/writinghandler/#subcommands","text":"Subcommands are similar but are more \"nested\". Each layer will be represented and separated by a . Take a look at this command that was registered command_configuration = DiscordCommand ( name = \"forex\" , description = \"Get Forex rates\" , options = [ SubcommandOption ( name = \"latest\" , description = \"Get latest forex rates.\" , type = 2 , options = [ CommandOption ( name = \"convert\" , description = \"View rates between two symbols.\" , type = 1 , required = False , options = [ { \"name\" : \"symbol_1\" , \"description\" : \"Symbol 1\" , \"type\" : CommandTypes . STRING , \"required\" : True , }, { \"name\" : \"symbol_2\" , \"description\" : \"Symbol 2\" , \"type\" : CommandTypes . STRING , \"required\" : False , }, ], ) ], ) ], ) When a user uses this command in discord. They'd use it as /forex latest convert <SYMBOL 1> <SYMBOL 2> The command identifier would be represented as forex.latest.convert","title":"Subcommands"},{"location":"responses/writinghandler/#defining-the-arguments","text":"You must define the same number of arguments in your python function as the discord command . Warning If you have an optional argument, you can pass the **kwargs argument to your function. Learn more about the *kwargs argument here . If the user adds an optional argument, this will be passed to the function. Otherwise, it will not be present. Write your code to check if it exists before doing anything! The command argument names must match to the one set as the value when registering your command. @bot . interaction . on ( \"forex.latest.convert\" ) async def handle_forex_convert ( symbol_1 : str , symbol_2 : str , ctx : IncomingDiscordInteraction ) -> DiscordResponse : ...","title":"Defining the arguments"},{"location":"tutorial/Configuring%20commands/","text":"Configuring commands \u00b6 Creating a command is very similar to creating it in JSON, however, this library will assist you in making sure the outcome is a valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to integrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow the discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.register.models import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.register.models import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not covered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command. Source \u00b6 import dataclasses import typing from pydantic import BaseModel , Extra , validator from pydantic.error_wrappers import ValidationError from pydantic.errors import ArbitraryTypeError from enum import Enum try : from typing import Literal # pragma: no cover except ImportError : # pragma: no cover # backport from typing_extensions import Literal # pragma: no cover if typing . TYPE_CHECKING : # pragma: no cover static_check_init_args = dataclasses . dataclass else : def static_check_init_args ( cls ): return cls class CommandTypes ( int , Enum ): \"\"\"Easy access to command types. Attributes: BOOLEAN (int): Represents Type 5 CHANNEL (int): Represents Type 7 INTEGER (int): Represents Type 4 ROLE (int): Represents Type 8 STRING (int): Represents Type 3 SUB_COMMAND (int): Represents Type 1 SUB_COMMAND_GROUP (int): Represents Type 2 USER (int): Represents Type 6 MENTIONABLE (int): Represents Type 9 \"\"\" SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 MENTIONABLE = 9 @static_check_init_args class CommandChoice ( BaseModel ): \"\"\"Represents a key-value command choice.\"\"\" name : str value : str @static_check_init_args class CommandOption ( BaseModel ): \"\"\"Represents a standard command option (not a subcommand).\"\"\" class Config : arbitrary_types_allowed = True name : str description : str type : CommandTypes required : bool = False choices : typing . Optional [ typing . Union [ typing . List [ dict ], typing . List [ CommandChoice ]] ] = None options : typing . Optional [ typing . Union [ typing . List [ CommandChoice ], typing . List ] ] = None # @validator(\"options\") # def options_allow_only_if_subcommand(cls, v): # if cls.type != 1: # raise ValidationError(\"Type must be 1 in order to have options.\") # return v @static_check_init_args class SubcommandOption ( BaseModel ): \"\"\"Represents a subcommand group usually you would put this as an option in a DiscordCommand\"\"\" class Config : arbitrary_types_allowed = True name : str description : str options : typing . List [ CommandOption ] type : Literal [ 2 ] = 2 # @validator(\"options\", pre=True, always=True) # def options_must_contain_type_1(cls, v): # pylint: disable=no-self-argument # item: CommandOption # for item_location, item in enumerate(v): # if isinstance(item, CommandOption): # _type = item.type # _error_name = item.name # elif isinstance(item, dict): # _type = item[\"type\"] # _error_name = item[\"name\"] # # if _type != 1: # raise ValueError( # f\"CommandOptions <{_error_name}> located <{item_location}> must be have type of 1 due to parent being a subcommand.\" # ) # return v @static_check_init_args class DiscordCommand ( BaseModel ): \"\"\"Represents a discord command.\"\"\" id : typing . Optional [ int ] name : str description : str options : typing . List [ typing . Union [ SubcommandOption , CommandOption ]]","title":"Configuring Commands"},{"location":"tutorial/Configuring%20commands/#configuring-commands","text":"Creating a command is very similar to creating it in JSON, however, this library will assist you in making sure the outcome is a valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to integrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow the discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.register.models import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.register.models import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not covered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command.","title":"Configuring commands"},{"location":"tutorial/Configuring%20commands/#source","text":"import dataclasses import typing from pydantic import BaseModel , Extra , validator from pydantic.error_wrappers import ValidationError from pydantic.errors import ArbitraryTypeError from enum import Enum try : from typing import Literal # pragma: no cover except ImportError : # pragma: no cover # backport from typing_extensions import Literal # pragma: no cover if typing . TYPE_CHECKING : # pragma: no cover static_check_init_args = dataclasses . dataclass else : def static_check_init_args ( cls ): return cls class CommandTypes ( int , Enum ): \"\"\"Easy access to command types. Attributes: BOOLEAN (int): Represents Type 5 CHANNEL (int): Represents Type 7 INTEGER (int): Represents Type 4 ROLE (int): Represents Type 8 STRING (int): Represents Type 3 SUB_COMMAND (int): Represents Type 1 SUB_COMMAND_GROUP (int): Represents Type 2 USER (int): Represents Type 6 MENTIONABLE (int): Represents Type 9 \"\"\" SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 MENTIONABLE = 9 @static_check_init_args class CommandChoice ( BaseModel ): \"\"\"Represents a key-value command choice.\"\"\" name : str value : str @static_check_init_args class CommandOption ( BaseModel ): \"\"\"Represents a standard command option (not a subcommand).\"\"\" class Config : arbitrary_types_allowed = True name : str description : str type : CommandTypes required : bool = False choices : typing . Optional [ typing . Union [ typing . List [ dict ], typing . List [ CommandChoice ]] ] = None options : typing . Optional [ typing . Union [ typing . List [ CommandChoice ], typing . List ] ] = None # @validator(\"options\") # def options_allow_only_if_subcommand(cls, v): # if cls.type != 1: # raise ValidationError(\"Type must be 1 in order to have options.\") # return v @static_check_init_args class SubcommandOption ( BaseModel ): \"\"\"Represents a subcommand group usually you would put this as an option in a DiscordCommand\"\"\" class Config : arbitrary_types_allowed = True name : str description : str options : typing . List [ CommandOption ] type : Literal [ 2 ] = 2 # @validator(\"options\", pre=True, always=True) # def options_must_contain_type_1(cls, v): # pylint: disable=no-self-argument # item: CommandOption # for item_location, item in enumerate(v): # if isinstance(item, CommandOption): # _type = item.type # _error_name = item.name # elif isinstance(item, dict): # _type = item[\"type\"] # _error_name = item[\"name\"] # # if _type != 1: # raise ValueError( # f\"CommandOptions <{_error_name}> located <{item_location}> must be have type of 1 due to parent being a subcommand.\" # ) # return v @static_check_init_args class DiscordCommand ( BaseModel ): \"\"\"Represents a discord command.\"\"\" id : typing . Optional [ int ] name : str description : str options : typing . List [ typing . Union [ SubcommandOption , CommandOption ]]","title":"Source"},{"location":"tutorial/Getting%20Started/","text":"Getting Started \u00b6 Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice An example bot is available here","title":"Getting Started"},{"location":"tutorial/Getting%20Started/#getting-started","text":"Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice An example bot is available here","title":"Getting Started"},{"location":"tutorial/Registering%20Commands/","text":"Registering Commands \u00b6 We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering, and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register . ( command_to_be_created ) \u00b6 Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#registering-commands","text":"We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering, and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register . ( command_to_be_created )","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#dispike.register.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict ( exclude_none = True ) _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = _command_to_json ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"dispike.register.registrator.RegisterCommands.register"},{"location":"tutorial/Running%20the%20bot/","text":"Running your bot. \u00b6 Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckily there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok. Start ngrok. \u00b6 Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification. Start the bot. \u00b6 There are multiple ways to run the bot. We\u2019re going to use the simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass. Run some commands. \u00b6 Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Running The Bot"},{"location":"tutorial/Running%20the%20bot/#running-your-bot","text":"Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckily there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok.","title":"Running your bot."},{"location":"tutorial/Running%20the%20bot/#start-ngrok","text":"Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification.","title":"Start ngrok."},{"location":"tutorial/Running%20the%20bot/#start-the-bot","text":"There are multiple ways to run the bot. We\u2019re going to use the simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass.","title":"Start the bot."},{"location":"tutorial/Running%20the%20bot/#run-some-commands","text":"Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Run some commands."},{"location":"tutorial/Writing%20the%20handler/","text":"Writing your first handler. \u00b6 You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , or a dict . Warning If you return a dict , it will not be verified and Dispike will assume that\u2019s valid and return the result to Discord. Your function must accept the same number of arguments you registered with Discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an argument named person , the function argument must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python Incoming Context \u00b6 Earlier you learned that you must account for an extra argument due to Dispike also passing a context about the command to your argument. Incoming context is type hinted, and your IDE should be able to auto-complete attributes. Writing your function \u00b6 from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . interaction . on ( \"wave\" ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.interaction.on(\u2018wave\u2019) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument is named \u201cperson\u201d, as well as the context that we will be receiving. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests faster, as Dispike would not have to guess what your response type is.","title":"Writing The Handler"},{"location":"tutorial/Writing%20the%20handler/#writing-your-first-handler","text":"You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , or a dict . Warning If you return a dict , it will not be verified and Dispike will assume that\u2019s valid and return the result to Discord. Your function must accept the same number of arguments you registered with Discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an argument named person , the function argument must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python","title":"Writing your first handler."},{"location":"tutorial/Writing%20the%20handler/#incoming-context","text":"Earlier you learned that you must account for an extra argument due to Dispike also passing a context about the command to your argument. Incoming context is type hinted, and your IDE should be able to auto-complete attributes.","title":"Incoming Context"},{"location":"tutorial/Writing%20the%20handler/#writing-your-function","text":"from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . interaction . on ( \"wave\" ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.interaction.on(\u2018wave\u2019) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument is named \u201cperson\u201d, as well as the context that we will be receiving. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests faster, as Dispike would not have to guess what your response type is.","title":"Writing your function"}]}